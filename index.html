<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>gap.oi</title>
<style>
body { margin:0; overflow:hidden; background:#eee; font-family:Arial; }
#ui, #leaderboard {
    position:fixed;
    background:rgba(255,255,255,.85);
    padding:8px;
    border-radius:6px;
}
#ui { top:10px; left:10px; }
#leaderboard { top:10px; right:10px; }
#minimap {
    position:fixed;
    bottom:10px;
    left:10px;
    border:2px solid #333;
    background:#fff;
}
#startScreen {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.7);
    color:white;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:32px;
    cursor:pointer;
    z-index:10;
}
</style>
</head>
<body>

<div id="startScreen">CLICK / PRESS ANY KEY TO START</div>

<canvas id="game"></canvas>
<canvas id="minimap" width="150" height="150"></canvas>

<div id="ui">
    Size: <span id="size">20</span><br>
    Level: <span id="level">1</span>
</div>

<div id="leaderboard">
    <b>Leaderboard</b>
    <ol id="board"></ol>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const mini = document.getElementById("minimap");
const mctx = mini.getContext("2d");
const startScreen = document.getElementById("startScreen");

canvas.width = innerWidth;
canvas.height = innerHeight;

const WORLD = 6000;
const names = ["Void","Abyss","Sink","Gloop","Orbit","Rift","Null","Drop","Echo"];

let keys = {}, running = false;
let camera, player, foods, bots, level;

document.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if (!running) startGame();
});
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
startScreen.onclick = startGame;

/* ---------- START / RESET ---------- */
function startGame() {
    running = true;
    startScreen.style.display = "none";
    resetGame();
}

function resetGame() {
    camera = { x:0, y:0, zoom:1 };
    level = 1;

    player = {
        name:"YOU",
        x:WORLD/2,
        y:WORLD/2,
        r:20,
        speed:4,
        color:"#000"
    };

    foods = [];
    bots = [];

    spawnLevel();
}

function spawnLevel() {
    foods.length = 0;
    bots.length = 0;

    for (let i=0;i<400+level*120;i++) spawnFood();
    for (let i=0;i<6+level*2;i++) spawnBot();
}

/* ---------- SPAWN ---------- */
function rand(n){ return Math.random()*n; }

function spawnFood() {
    foods.push({
        x:rand(WORLD),
        y:rand(WORLD),
        r:rand(10)+5,
        color:`hsl(${rand(360)},70%,50%)`
    });
}

function spawnBot() {
    bots.push({
        name:names[Math.floor(rand(names.length))],
        x:rand(WORLD),
        y:rand(WORLD),
        r:rand(18)+18+level*2,
        speed:2+rand(1.2),
        dir:rand(Math.PI*2),
        color:`hsl(${rand(360)},70%,40%)`
    });
}

/* ---------- MOVEMENT ---------- */
function movePlayer() {
    if (keys.w||keys.arrowup) player.y -= player.speed;
    if (keys.s||keys.arrowdown) player.y += player.speed;
    if (keys.a||keys.arrowleft) player.x -= player.speed;
    if (keys.d||keys.arrowright) player.x += player.speed;
}

function moveBots() {
    for (let b of bots) {
        let fleeTarget = null;
        let attackTarget = null;
        let foodTarget = null;
        let minFoodDist = Infinity;

        // 1️⃣ Threats (player or bigger bots)
        if (player.r > b.r * 1.15) {
            fleeTarget = player;
        }
        for (let o of bots) {
            if (o !== b && o.r > b.r * 1.15) {
                fleeTarget = o;
            }
        }

        // 2️⃣ Attack player if bot is bigger
        if (!fleeTarget && b.r > player.r * 1.15) {
            attackTarget = player;
        }

        // 3️⃣ Attack smaller bots
        if (!attackTarget && !fleeTarget) {
            for (let o of bots) {
                if (o !== b && b.r > o.r * 1.25) {
                    attackTarget = o;
                    break;
                }
            }
        }

        // 4️⃣ Eat nearest food
        if (!attackTarget && !fleeTarget) {
            for (let f of foods) {
                let d = Math.hypot(f.x-b.x, f.y-b.y);
                if (b.r > f.r && d < minFoodDist) {
                    minFoodDist = d;
                    foodTarget = f;
                }
            }
        }

        // Decide direction
        if (fleeTarget) {
            b.dir = Math.atan2(b.y-fleeTarget.y, b.x-fleeTarget.x);
        } else if (attackTarget) {
            b.dir = Math.atan2(attackTarget.y-b.y, attackTarget.x-b.x);
        } else if (foodTarget) {
            b.dir = Math.atan2(foodTarget.y-b.y, foodTarget.x-b.x);
        } else {
            b.dir += (Math.random()-0.5)*0.3;
        }

        b.x += Math.cos(b.dir) * b.speed;
        b.y += Math.sin(b.dir) * b.speed;
    }
}

/* ---------- COLLISIONS ---------- */
function absorb(a,b){ a.r += b.r * 0.18; }

function eat(entity, arr) {
    for (let i=arr.length-1;i>=0;i--) {
        let o = arr[i];
        let d = Math.hypot(entity.x-o.x, entity.y-o.y);
        if (d < entity.r + o.r && entity.r > o.r * 1.05) {
            absorb(entity,o);
            arr.splice(i,1);
            if (arr === foods) spawnFood();
        }
    }
}

function collisions() {
    eat(player, foods);
    bots.forEach(b => eat(b, foods));

    for (let i=bots.length-1;i>=0;i--) {
        let b = bots[i];
        let d = Math.hypot(player.x-b.x, player.y-b.y);
        if (d < player.r + b.r) {
            if (player.r > b.r * 1.05) {
                absorb(player,b);
                bots.splice(i,1);
            } else {
                running = false;
                startScreen.style.display = "flex";
                startScreen.textContent = "GAME OVER — CLICK TO RESTART";
            }
        }
    }
}

/* ---------- CAMERA ---------- */
function updateCamera() {
    camera.zoom = 1 / (1 + player.r / 300);
    camera.x = player.x - canvas.width / camera.zoom / 2;
    camera.y = player.y - canvas.height / camera.zoom / 2;
}

/* ---------- DRAW ---------- */
function draw() {
    ctx.setTransform(camera.zoom,0,0,camera.zoom,-camera.x*camera.zoom,-camera.y*camera.zoom);
    ctx.clearRect(camera.x,camera.y,canvas.width/camera.zoom,canvas.height/camera.zoom);

    foods.forEach(f=>{
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        ctx.fillStyle=f.color;
        ctx.fill();
    });

    bots.forEach(b=>{
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
        ctx.fillStyle=b.color;
        ctx.fill();
    });

    ctx.beginPath();
    ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
    ctx.fillStyle=player.color;
    ctx.fill();

    size.textContent = Math.floor(player.r);
    level.textContent = level;
}

/* ---------- MINIMAP (FIXED) ---------- */
function drawMinimap() {
    mctx.clearRect(0,0,150,150);
    const s = 150 / WORLD;

    // player
    mctx.fillStyle = "#000";
    mctx.fillRect(player.x*s, player.y*s, 4, 4);

    // ALL bots (no skipping)
    mctx.fillStyle = "red";
    bots.forEach(b=>{
        mctx.fillRect(b.x*s, b.y*s, 3, 3);
    });
}

/* ---------- LEADERBOARD ---------- */
function leaderboard() {
    board.innerHTML="";
    [player,...bots].sort((a,b)=>b.r-a.r).slice(0,5)
        .forEach(e=>{
            let li=document.createElement("li");
            li.textContent=`${e.name} (${Math.floor(e.r)})`;
            board.appendChild(li);
        });
}

/* ---------- LOOP ---------- */
function loop() {
    if (running) {
        movePlayer();
        moveBots();
        collisions();
        updateCamera();
        draw();
        drawMinimap();
        leaderboard();
    }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>


